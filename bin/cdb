#!/usr/bin/env ruby

require 'cdb-crawlr'
require 'optparse'

options = {}
scopes = ['all', 'title', 'issue']

def print_help(opt = @global)
  puts opt
  exit 1
end

@global = OptionParser.new do |opts|
  opts.banner = "Usage: cdb [-h|--help] [-v|--version] <command> [<args>]"

  opts.on("-h", "--help", "Display this screen"){ print_help }
  opts.on("-v", "--version", "Show version information") do
    puts "cdb #{CDB::VERSION}"; exit
  end
end

@search = OptionParser.new do |opts|
  opts.banner = "Usage: cdb search [-h|--help] [-s|--scope=<type>] [<args>]"

  opts.on("-h", "--help", "Display this screen"){ print_help opts }
  opts.on("-s", "--scope=<type>", "Specify type of search. Default: all") do |v|
    options[:scope] = v.strip.downcase.chomp('s')
    unless scopes.include?( options[:scope] )
      puts "invalid scope: #{v}"
      print_help opts
    end
  end
end

@command_opts = {
  'search' => @search
}

# Parse global flags
begin
  @global.order!
rescue OptionParser::InvalidOption => e
  puts e; print_help
end

# Pop and verify command
options[:command] = ARGV.shift.downcase rescue nil
unless command_opt = @command_opts[options[:command]]
  if options[:command] && !options[:command].empty?
    puts "invalid command: #{options[:command]}"
  end
  print_help
end

# Parse command flags
begin
  command_opt.order!
rescue OptionParser::InvalidOption, OptionParser::MissingArgument => e
  puts e; print_help command_opt
end

# Pop and verify args
options[:args] = ARGV.join(' ')
if options[:args].empty?
  puts "empty #{options[:command]} arguments"
  print_help command_opt
end

puts options
